<!--
 * @Description: des
 * @Date: 2020-05-27 09:11:25
 * @Author: LB
-->
<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>实时语音</title>
    <style type="text/css">
      .tool {
        display: flex;
      }

      .tool .btn {
        margin: 10px;
        padding: 5px 8px;
        color: #fff;
        background-color: #f60;
        border-radius: 5px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="tool" class="tool">
      <span data-opt="open" class="btn">打开</span>
      <span data-opt="start" class="btn">开始</span>
      <span data-opt="stop" class="btn">结束</span>
      <span data-opt="close" class="btn">关闭</span>
      <span data-opt="play" class="btn">播放</span>
    </div>

    <!-- 【1.1】引入核心文件 -->
    <script src="https://cdn.jsdelivr.net/gh/xiangyuecn/Recorder@latest/src/recorder-core.js"></script>

    <!-- 【1.2】引入相应格式支持文件；如果需要多个格式支持，把这些格式的编码引擎js文件放到后面统统加载进来即可 -->
    <script src="https://cdn.jsdelivr.net/gh/xiangyuecn/Recorder@latest/src/engine/mp3.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/xiangyuecn/Recorder@latest/src/engine/mp3-engine.js"></script>

    <!-- 【1.3】引入可选的扩展支持项，如果不需要这些扩展功能可以不引入 -->
    <script src="https://cdn.jsdelivr.net/gh/xiangyuecn/Recorder@latest/src/extensions/frequency.histogram.view.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/xiangyuecn/Recorder@latest/src/extensions/lib.fft.js"></script>
    <script>
      /* 
      流程
      1、HTML5 Recorder 浏览器采集原始音频数据
      2、实时转码为 mp3 文件，websocket 实时上传至服务器
      3、服务器分发其他客户端
      4、客户端接收服务端数据，合并多个 mp3 文件，播放
      */

      console.log('open index.html');

      var testOutputWavLog = false; //顺带打一份wav的log，录音后执行mp3、wav合并的demo代码可对比音质
      var testSampleRate = 16000;
      var testBitRate = 16;

      var SendInterval = 300; //mp3 chunk数据会缓冲，当pcm的累积时长达到这个时长，就会传输发送。这个值在takeoffEncodeChunk实现下，使用0也不会有性能上的影响。

      //重置环境
      var RealTimeSendTryReset = function() {
        realTimeSendTryTime = 0;
      };

      var realTimeSendTryTime = 0;
      var realTimeSendTryNumber;
      var transferUploadNumberMax;
      var realTimeSendTryBytesChunks;
      var realTimeSendTryClearPrevBufferIdx;
      var realTimeSendTryWavTestBuffers;
      var realTimeSendTryWavTestSampleRate;

      //=====实时处理核心函数==========
      var RealTimeSendTry = function(chunkBytes, isClose) {
        if (chunkBytes) {
          //推入缓冲再说
          realTimeSendTryBytesChunks.push(chunkBytes);
        }

        var t1 = Date.now();
        if (!isClose && t1 - realTimeSendTryTime < SendInterval) {
          return; //控制缓冲达到指定间隔才进行传输
        }
        realTimeSendTryTime = t1;
        var number = ++realTimeSendTryNumber;

        // mp3缓冲的chunk拼接成一个更长点的mp3
        var len = 0;
        for (var i = 0; i < realTimeSendTryBytesChunks.length; i++) {
          len += realTimeSendTryBytesChunks[i].length;
        }
        var chunkData = new Uint8Array(len);
        for (var i = 0, idx = 0; i < realTimeSendTryBytesChunks.length; i++) {
          var chunk = realTimeSendTryBytesChunks[i];
          chunkData.set(chunk, idx);
          idx += chunk.length;
        }
        realTimeSendTryBytesChunks = [];
        //推入传输
        var blob = null,
          meta = {};
        if (chunkData.length > 0) {
          //mp3不是空的
          blob = new Blob([chunkData], { type: 'audio/mp3' });
          meta =
            Recorder.mp3ReadMeta([chunkData.buffer], chunkData.length) || {}; //读取出这个mp3片段信息
        }

        TransferUpload(
          number,
          chunkData,
          meta.duration || 0,
          {
            set: {
              type: 'mp3',
              sampleRate: meta.sampleRate,
              bitRate: meta.bitRate
            }
          },
          isClose
        );

        if (testOutputWavLog) {
          //测试输出一份wav，方便对比数据
          var recMock2 = Recorder({
            type: 'wav',
            sampleRate: testSampleRate,
            bitRate: 16
          });
          var chunk = Recorder.SampleData(
            realTimeSendTryWavTestBuffers,
            realTimeSendTryWavTestSampleRate,
            realTimeSendTryWavTestSampleRate
          );
          recMock2.mock(chunk.data, realTimeSendTryWavTestSampleRate);
          recMock2.stop(function(blob, duration) {
            var logMsg =
              'No.' + (number < 100 ? ('000' + number).substr(-3) : number);
            Runtime.LogAudio(blob, duration, recMock2, logMsg);
          });
        }
        realTimeSendTryWavTestBuffers = [];
      };

      //=====实时处理时清理一下内存（延迟清理），本方法先于RealTimeSendTry执行======
      var RealTimeOnProcessClear = function(
        buffers,
        powerLevel,
        bufferDuration,
        bufferSampleRate,
        newBufferIdx,
        asyncEnd
      ) {
        if (realTimeSendTryTime == 0) {
          realTimeSendTryTime = Date.now();
          realTimeSendTryNumber = 0;
          transferUploadNumberMax = 0;
          realTimeSendTryBytesChunks = [];
          realTimeSendTryClearPrevBufferIdx = 0;
          realTimeSendTryWavTestBuffers = [];
          realTimeSendTryWavTestSampleRate = 0;
        }

        //清理PCM缓冲数据，最后完成录音时不能调用stop，因为数据已经被清掉了
        //这里进行了延迟操作（必须要的操作），只清理上次到现在的buffer
        for (var i = realTimeSendTryClearPrevBufferIdx; i < newBufferIdx; i++) {
          buffers[i] = null;
        }
        realTimeSendTryClearPrevBufferIdx = newBufferIdx;

        //备份一下方便后面生成测试wav
        for (var i = newBufferIdx; i < buffers.length; i++) {
          realTimeSendTryWavTestBuffers.push(buffers[i]);
        }
        realTimeSendTryWavTestSampleRate = bufferSampleRate;
      };

      //=====数据传输函数==========
      var TransferUpload = function(
        number,
        chunkData,
        duration,
        blobRec,
        isClose
      ) {
        transferUploadNumberMax = Math.max(transferUploadNumberMax, number);
        if (chunkData) {
          var blob = chunkData;
          /*  var reader = new FileReader();
          reader.onloadend = function() {
            var base64 = (/.+;\s*base64\s*,\s*(.+)$/i.exec(reader.result) ||
              [])[1];
            ws.send(base64);
          };
          reader.readAsDataURL(blob); */
          /*  
          ws.send(uint8Array.buffer); */

          //*********Blob***************
          //可以实现
          //WebSocket send(blob) ...
          //WebRTC send(blob) ...
          //XMLHttpRequest send(blob) ...

          // ws.send('TransferUpload' + Date.now());
          const buffer = chunkData.buffer;
          console.log('send');
          ws.send(buffer);
        }

        if (isClose) {
          Runtime.Log(
            'No.' +
              (number < 100 ? ('000' + number).substr(-3) : number) +
              ':已停止传输'
          );
        }
      };

      // 播放标签
      let audio = null;
      // 播放列表
      const playFiles = [];

      // 实时合并播放音频
      function realTimePlayMp3() {
        const tempQueue = fileQueue;
        fileQueue = [];
        const fileBytesList = tempQueue.map(file => {
          let array = new Uint8Array(file);
          return array;
        });
        // 合并成功
        const successFn = function(fileBytes, duration, info) {
          const blob = new Blob([fileBytes]);
          playFiles.push(blob);
          if (!audio) {
            createAudio();
            playAudio();
          }
        };

        Mp3Merge(fileBytesList, successFn);
      }

      function createAudio() {
        audio = document.createElement('audio');
        document.body.appendChild(audio);
        audio.controls = true;
        audio.loop = false;
        audio.onended = function() {
          if (playFiles.length > 0) {
            playAudio();
          }
        };
      }

      function playAudio() {
        const blob = playFiles.shift();
        if (!blob) {
          return;
        }
        // 简单利用URL生成播放地址，注意不用了时需要revokeObjectURL，否则霸占内存
        audio.src = (window.URL || webkitURL).createObjectURL(blob);
        audio.play();
        setTimeout(() => {
          (window.URL || webkitURL).revokeObjectURL(audio.src);
        }, 5 * 1000);
      }

      let recorder = null;
      let ws = null;
      const userID = Date.now();
      let fileQueue = [];

      // 创建 websocket
      function createWSconnection() {
        if (window.WebSocket && ws === null) {
          ws = new WebSocket('ws://127.0.0.1:8001');

          // 传输方式改为arraybuffer
          ws.binaryType = 'arraybuffer';

          ws.onopen = function(e) {
            console.log('连接服务器成功');
            ws.send('connect' + Date.now());
          };

          ws.onclose = function(e) {
            // 关闭录音
            recorder.stop();
            console.log('服务器关闭');
          };

          ws.onerror = function() {
            console.log('连接出错');
          };

          ws.onmessage = function(e) {
            const msg = e.data;
            console.log('receive');
            fileQueue.push(msg);
            realTimePlayMp3();
          };
        }
      }

      // 创建 recorder 实体
      function createRecorderEntity() {
        if (recorder !== null) {
          return;
        }

        //  注意：是数字的参数必须提供数字，不要用字符串；需要使用的type类型，需提前把格式支持文件加载进来，比如使用wav格式需要提前加载wav.js编码引擎
        recorder = Recorder({
          // mp3格式
          type: 'mp3',
          // 指定采样率hz
          sampleRate: 16000,
          // 比特率kbps，其他参数使用默认配置
          bitRate: 16,
          // 录音实时回调，大约1秒调用12次本回调
          onProcess: onRecorderProcess,

          // 将直接得到的 PCM 片段编码生成 mp3 数据
          takeoffEncodeChunk: function(chunkBytes) {
            //接管实时转码，推入实时处理
            RealTimeSendTry(chunkBytes, false);
          }
        });
      }

      // 监听录音实时回调
      function onRecorderProcess(
        // buffer 中 PCM 数据，为浏览器采集的原始音频数据
        buffers,
        powerLevel,
        bufferDuration,
        bufferSampleRate,
        newBufferIdx,
        asyncEnd
      ) {
        RealTimeOnProcessClear(
          buffers,
          powerLevel,
          bufferDuration,
          bufferSampleRate,
          newBufferIdx,
          asyncEnd
        );
      }

      // 打开麦克风，获取权限
      function openRecorder() {
        recorder.open(
          function sucess() {
            console.log('open sucess');
          },
          function fail() {
            console.log('open fail');
          }
        );
      }

      // mp3 多个片段文件合并
      function Mp3Merge(fileBytesList, successFn) {
        // 合并失败
        const failFn = function(errMsg) {
          console.log(errMsg);
        };

        //计算所有文件的长度、校验mp3信息
        let size = 0,
          baseInfo = null;
        for (let i = 0; i < fileBytesList.length; i++) {
          let file = fileBytesList[i];
          let info = readMp3Info(file);
        

          if (!info) {
            failFn &&
              failFn('第' + (i + 1) + '个文件不是lamejs mp3格式音频，无法合并');
            return;
          }
          baseInfo || (baseInfo = info);
          if (
            baseInfo.sampleRate != info.sampleRate ||
            baseInfo.bitRate != info.bitRate
          ) {
            failFn && failFn('第' + (i + 1) + '个文件比特率或采样率不一致');
            return;
          }

          size += file.byteLength;
        }
        if (size > 50 * 1024 * 1024) {
          failFn && failFn('文件大小超过限制');
          return;
        }

        //全部直接拼接到一起
        let fileBytes = new Uint8Array(size);
        let pos = 0;
        for (let i = 0; i < fileBytesList.length; i++) {
          let bytes = fileBytesList[i];
          fileBytes.set(bytes, pos);
          pos += bytes.byteLength;
        }

        //计算合并后的总时长
        let duration = Math.round((size * 8) / baseInfo.bitRate);

        successFn(fileBytes, duration, baseInfo);
      }

      // 读取文件信息
      function readMp3Info(bytes) {
        if (bytes.byteLength < 4) {
          return null;
        }
        let byteAt = function(idx, u8) {
          return ('0000000' + ((u8 || bytes)[idx] || 0).toString(2)).substr(-8);
        };
        let b2 = byteAt(0) + byteAt(1);
        let b4 = byteAt(2) + byteAt(3);

        if (!/^1{11}/.test(b2)) {
          //未发现帧同步
          return null;
        }
        let version = { '00': 2.5, '10': 2, '11': 1 }[b2.substr(11, 2)];
        let layer = { '01': 3 }[b2.substr(13, 2)]; //仅支持Layer3
        let sampleRate = {
          //lamejs -> Tables.samplerate_table
          '1': [44100, 48000, 32000],
          '2': [22050, 24000, 16000],
          '2.5': [11025, 12000, 8000]
        }[version];
        sampleRate && (sampleRate = sampleRate[parseInt(b4.substr(4, 2), 2)]);
        let bitRate = [
          //lamejs -> Tables.bitrate_table
          [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], //MPEG 2 2.5
          [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320] //MPEG 1
        ][version == 1 ? 1 : 0][parseInt(b4.substr(0, 4), 2)];

        if (!version || !layer || !bitRate || !sampleRate) {
          return null;
        }

        return {
          version: version, //1 2 2.5 -> MPEG1 MPEG2 MPEG2.5
          layer: layer, //3 -> Layer3
          sampleRate: sampleRate, //采样率 hz
          bitRate: bitRate //比特率 kbps
        };
      }

      // 监听操作
      function addEvent() {
        const tool = document.getElementById('tool');
        tool.onclick = function(e) {
          const opt = e.target.dataset.opt;

          if (!opt) {
            return;
          }

          switch (opt) {
            case 'open':
              console.log('open');
              recorder.open(
                function success() {
                  console.log('open success');
                },
                function fail() {
                  console.log('open fail');
                }
              );
              break;
            case 'start':
              console.log('start start');
              recorder.start();
              break;
            case 'stop':
              console.log('stop');
              // 获取到录音数据 blob
              recorder.stop(
                function success(blob, duration) {
                  console.log('stop');

                  /*   
                  const audio = document.createElement('audio');
                  audio.controls = true;
                  document.body.appendChild(audio);
                  // 简单利用URL生成播放地址，注意不用了时需要revokeObjectURL，否则霸占内存
                  audio.src = (window.URL || webkitURL).createObjectURL(blob);
                  audio.play(); */
                },
                function fail(msg) {
                  console.log('录音失败:' + msg);
                }
              );
              break;
            case 'close':
              console.log('close');
              recorder.close();
              break;
            case 'play':
              console.log('play');
              const fileBytesList = fileQueue.map(file => {
                let array = new Uint8Array(file);
                return array;
              });
              // 合并成功
              const successFn = function(fileBytes, duration, info) {
                console.log('Mp3Merge successFn');
                const audio = document.createElement('audio');
                audio.controls = true;
                document.body.appendChild(audio);
                const blob = new Blob([fileBytes]);
                // 简单利用URL生成播放地址，注意不用了时需要revokeObjectURL，否则霸占内存
                audio.src = (window.URL || webkitURL).createObjectURL(blob);
                audio.play();
              };
              console.log('Mp3Merge');

              Mp3Merge(fileBytesList, successFn);
              break;
            default:
              break;
          }
        };
      }

      // 开始执行
      window.onload = function init() {
        console.log('onload');
        createWSconnection();
        createRecorderEntity();
        addEvent();
      };
    </script>
  </body>
</html>
